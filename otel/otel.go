package otel

import (
	"context"
	"crypto/rand"
	"fmt"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	tracesdk "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

const defaultComponentName = "echo/v4"
const tracerName = "echo-otel-tracer"

type OtelConfig struct {
	serviceName           string
	collectorHostName     string
	collectorPort         int
	samplingRate          float64
	collectorTraceTimeout int
	skipper               middleware.Skipper
	tracer                trace.Tracer
}

var DefaultOtelConfig = OtelConfig{
	serviceName:           "echo-otel",
	collectorHostName:     "jaeger",
	collectorPort:         4317,
	samplingRate:          1,
	collectorTraceTimeout: 2,
	skipper:               nil,
	tracer:                nil,
}

func CreateSpan(ctx context.Context, name string) (trace.Span, context.Context) {
	tracer := otel.Tracer(tracerName)
	ctx, span := tracer.Start(
		ctx,
		name,
	)

	return span, ctx
}

func New(e *echo.Echo, cfg OtelConfig, skipper middleware.Skipper) {
	// Add Opentracing instrumentation
	if cfg.tracer == nil {
		panic("echo: trace middleware requires opentracing tracer")
	}
	if cfg.skipper == nil {
		cfg.skipper = middleware.DefaultSkipper
	}
	if cfg.serviceName == "" {
		cfg.serviceName = defaultComponentName
	}

	tracer := createGlobalTracer(cfg)

	e.Use(TraceWithConfig(OtelConfig{
		tracer:  tracer,
		skipper: skipper,
	}))
}

// TraceWithConfig returns a Trace middleware with config.
// See: `Trace()`.
func TraceWithConfig(config OtelConfig) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if config.skipper(c) {
				return next(c)
			}

			req := c.Request()
			realIP := c.RealIP()
			requestID := getRequestID(c) // request-id generated by reverse-proxy

			var err error

			ctx, span := config.tracer.Start(c.Request().Context(), c.Request().RequestURI)
			defer span.End()

			span.SetAttributes(
				attribute.String("request_id", requestID),
				attribute.String("client_ip", realIP),
				attribute.String("component", config.serviceName),
				attribute.String("url", req.URL.String()),
				attribute.String("method", req.Method),
			)

			// setup request context - add opentracing span
			reqSpan := req.WithContext(ctx)
			c.SetRequest(reqSpan)
			defer func() {
				// as we have created new http.Request object we need to make sure that temporary files created to hold MultipartForm
				// files are cleaned up. This is done by http.Server at the end of request lifecycle but Server does not
				// have reference to our new Request instance therefore it is our responsibility to fix the mess we caused.
				//
				// This means that when we are on returning path from handler middlewares up in chain from this middleware
				// can not access these temporary files anymore because we deleted them here.
				if reqSpan.MultipartForm != nil {
					reqSpan.MultipartForm.RemoveAll()
				}
			}()

			// call next middleware / controller
			err = next(c)
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
				c.Error(err) // call custom registered error handler
			}

			status := c.Response().Status
			span.SetAttributes(
				attribute.Int("status", status),
			)

			return nil // error was already processed with ctx.Error(err)
		}
	}
}

func createGlobalTracer(cfg OtelConfig) trace.Tracer {
	//"jaeger:4317"
	exporter, err := createTraceExporter(cfg)

	if err != nil {
		panic("unable to create trace exporter")
	}

	tp := tracesdk.NewTracerProvider(
		tracesdk.WithSampler(tracesdk.ParentBased(tracesdk.TraceIDRatioBased(cfg.samplingRate))),
		tracesdk.WithBatcher(exporter),
		tracesdk.WithResource(resource.NewWithAttributes(
			semconv.SchemaURL,
			semconv.ServiceName(cfg.serviceName),
			attribute.String("environment", "env"),
		)),
	)

	otel.SetTracerProvider(tp)
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}))

	return otel.Tracer(tracerName)
}

func createTraceExporter(cfg OtelConfig) (*otlptrace.Exporter, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cfg.collectorTraceTimeout)*time.Second)
	defer cancel()

	conn, err := grpc.DialContext(
		ctx,
		fmt.Sprintf("%s:%d", cfg.collectorHostName, cfg.collectorPort),
		// Note the use of insecure transport here. TLS is recommended in production.
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, err
	}

	traceExporter, err := otlptracegrpc.New(ctx, otlptracegrpc.WithGRPCConn(conn))
	if err != nil {
		return nil, err
	}

	return traceExporter, nil
}

func getRequestID(ctx echo.Context) string {
	requestID := ctx.Request().Header.Get(echo.HeaderXRequestID) // request-id generated by reverse-proxy
	if requestID == "" {
		requestID = generateToken() // missed request-id from proxy, we generate it manually
	}
	return requestID
}

func generateToken() string {
	b := make([]byte, 16)
	rand.Read(b)
	return fmt.Sprintf("%x", b)
}
